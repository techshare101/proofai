import jsPDF from 'jspdf';
import 'jspdf-autotable';
import QRCode from 'qrcode';

interface PolishedPDFInput {
  title?: string;
  date?: Date | null;
  summary?: string | {
    text: string;
    structuredSummaryText?: string;
  };
  content: string;
  caseId: string;
  location?: string;
  url?: string;
  folderPath?: string;
  filename?: string;
  mimeType?: string;
  videoUrl: string;
  reportDate: string | Date;
  participants?: string | string[];
  relevance?: string;
  legalRelevance?: string; // Legal relevance information (legacy field)
  original_transcript?: string; // Original transcript in detected language
  reportPublicUrl?: string; // Public URL for report verification QR code
  includeSignature?: boolean; // Whether to include the signature placeholder
  transcript?: string; // Added to fix compatibility issues
  language?: string; // Language of the transcript
  timezone?: string; // User's timezone (e.g., 'America/Chicago')
}

/**
 * Generates a professionally formatted PDF document with specified content and styling
 * @param options Input data for the PDF
 * @returns A Blob containing the generated PDF, ready for Supabase upload
 */
export async function generatePolishedPDF(options: PolishedPDFInput): Promise<Blob> {
  // Create a new PDF document with standard settings
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'pt',
    format: 'a4',
    // Adding Courier font which has better Unicode support
    putOnlyUsedFonts: true
  });
  
  // Add font that has better Unicode support
  doc.setFont('courier');
  
  // Set up document metadata for accessibility
  doc.setDocumentProperties({
    creator: 'ProofAI',
    title: `Case Report: ${options.caseId}`,
    subject: 'Transcript and Report Summary',
    keywords: 'ProofAI, Evidence, Legal',
    author: 'ProofAI System'
  });
  
  // Configure page margins and size
  const pageMargins = [40, 60, 40, 60]; // left, top, right, bottom
  // Page size is already set to A4 in jsPDF initialization
  
  // Document constants
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 50; // Margin in points
  const contentWidth = pageWidth - (margin * 2);
  
  // Typography settings
  doc.setFont('helvetica');
  doc.setFontSize(12);
  let lineHeight = 20; // ~1.5 line height at 12pt
  
  // Helper function to add page number and footer to each page
  const addPageNumber = () => {
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      
      // Add page numbers
      doc.setFont('helvetica');
      doc.setFontSize(10);
      doc.setTextColor(0, 0, 0); // Reset to black for page numbers
      const text = `Page ${i} of ${pageCount}`;
      const textWidth = doc.getStringUnitWidth(text) * 10 / doc.internal.scaleFactor;
      const textX = (pageWidth - textWidth) / 2;
      doc.text(text, textX, pageHeight - 25);
      
      // Add enhanced legal footer text in dark grey
      doc.setFontSize(9); // Reduced font size for legal footer
      doc.setTextColor(102, 102, 102); // Dark gray color (RGB: 102,102,102 or ~0.4,0.4,0.4)
      const footerText = 'Generated by ProofAI â€¢ www.proof.ai â€¢ This document is timestamped and immutable.';
      const footerWidth = doc.getStringUnitWidth(footerText) * 9 / doc.internal.scaleFactor; // Adjust for 9pt font
      const footerX = (pageWidth - footerWidth) / 2;
      doc.text(footerText, footerX, pageHeight - 15); // Position at y: 15 from bottom
    }
    
    // Reset text color after adding footers
    doc.setTextColor(0, 0, 0);
  };
  
  // Helper function to add section divider
  const addSectionDivider = () => {
    doc.setDrawColor(200);
    doc.line(margin, yPos, pageWidth - margin, yPos);
    yPos += lineHeight;
  };

  // Enhanced sanitize function for thoroughly removing emojis and special chars
  const sanitizeText = (text: string): string => {
    if (!text) return '';
    
    try {
      // Remove emoji characters - more comprehensive pattern
      const noEmoji = text.replace(/[\u{1F000}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F300}-\u{1F5FF}\u{1F900}-\u{1F9FF}\u{1F600}-\u{1F64F}\u{1F680}-\u{1F6FF}\u{2300}-\u{23FF}\u{2B50}\u{2B55}]/gu, '');
      
      // Remove other common symbols that might cause issues
      const noSymbols = noEmoji.replace(/[\u{1F1E0}-\u{1F1FF}\u{2702}-\u{27B0}\u{24C2}-\u{1F251}\u{1F004}\u{1F0CF}]/gu, '');
      
      // Remove control characters and other special encoding characters
      const noControlChars = noSymbols.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
      
      // Clean up other potential problematic characters
      const cleaned = noControlChars
        // Replace fancy quotes with regular quotes
        .replace(/[\u{201C}\u{201D}\u{2018}\u{2019}]/gu, '"')
        // Replace other special whitespace
        .replace(/[\u{2002}-\u{200D}\u{2060}\u{FEFF}]/gu, ' ')
        // Remove multiple consecutive spaces
        .replace(/\s+/g, ' ');
      
      // Normalize the text using NFC
      return cleaned.normalize('NFC');
    } catch (e) {
      console.warn('Failed to sanitize text:', e);
      // Fallback: strip non-ASCII characters
      return text.replace(/[^\x20-\x7E]/g, '');
    }
  };

  // Start position for content
  let yPos = margin;

  // Add CASE REPORT header
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('CASE REPORT', margin, yPos);
  yPos += lineHeight * 1.5;
  
  // Add location metadata (using geocoded address if available)
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(12);
  
  // Format the location to ensure it's human readable
  let displayLocation = sanitizeText(options.location || 'Unknown Location');
  
  // In case the location still contains lat/lng format after all our efforts
  if (displayLocation.startsWith('Lat:') || displayLocation.includes(',') && /[\d]+\.[\d]+/.test(displayLocation)) {
    displayLocation = 'Location information available but not geocoded';
  }
  
  // Display the location
  doc.text(`Location: ${displayLocation}`, margin, yPos);
  yPos += lineHeight * 2;
  
  // Set up monospaced font for the structured summary section
  doc.setFont('courier', 'normal');
  doc.setFontSize(12);
  
  // Format participants (convert array to string if needed and handle empty case)
  let participantsText = 'None listed';
  if (options.participants) {
    if (Array.isArray(options.participants) && options.participants.length > 0) {
      participantsText = sanitizeText(options.participants.join(', '));
    } else if (typeof options.participants === 'string' && options.participants.trim() !== '') {
      participantsText = sanitizeText(options.participants);
    }
  }
  
  // Skip the duplicate summary block entirely
  // Only keep the location at the top of the page
  
  // Add extra space before the structured summary section
  yPos += lineHeight * 0.5;
  
  // Add a visual divider for the structured summary section
  doc.setDrawColor(200, 200, 200);
  doc.setLineWidth(0.5);
  doc.line(margin, yPos, pageWidth - margin, yPos);
  yPos += lineHeight * 0.5;
  
  // Draw the REPORT SUMMARY section header - no emoji
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(14);
  doc.text('REPORT SUMMARY', margin, yPos);
  
  // Add a dashed line after the header
  yPos += lineHeight * 0.75;
  doc.setDrawColor(128, 128, 128); // Gray
  doc.setLineWidth(0.5);
  doc.setLineDashPattern([2, 2], 0); // Dashed line
  doc.line(margin, yPos, margin + 250, yPos);
  doc.setLineDashPattern([10, 0], 0); // Reset to solid line
  doc.setDrawColor(0); // Reset to black
  
  yPos += lineHeight * 1.2;
  
  // Function to draw a field with proper formatting
  const drawLabeledField = (label: string, value: string, color: string = '#000000', isBold: boolean = false) => {
    // Sanitize value to ensure clean rendering
    const sanitizedValue = sanitizeText(value || '');
    
    // Format label with proper styling
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(102, 0, 153); // Purple for labels - similar to 'SUMMARY' text in screenshot
    doc.text(`${label}:`, margin, yPos);
    
    // Set style for value
    doc.setFont('helvetica', isBold ? 'bold' : 'normal');
    
    // Set text color based on field - convert hex to RGB
    const r = parseInt(color.substring(1, 3), 16);
    const g = parseInt(color.substring(3, 5), 16);
    const b = parseInt(color.substring(5, 7), 16);
    doc.setTextColor(r, g, b);
    
    // Calculate offset for value (after label)
    const labelWidth = doc.getStringUnitWidth(`${label}: `) * doc.getFontSize() / doc.internal.scaleFactor;
    const xOffset = margin + labelWidth + 5;
    
    // Handle value possibly wrapping
    if (sanitizedValue.length > 50) {
      const lines = doc.splitTextToSize(sanitizedValue, pageWidth - xOffset - margin);
      doc.text(lines, xOffset, yPos);
      yPos += lineHeight * Math.max(1, lines.length * 0.8);
    } else {
      doc.text(sanitizedValue, xOffset, yPos);
      yPos += lineHeight;
    }
    
    // Reset text color to black
    doc.setTextColor(0, 0, 0);
  };
  
  // Extract and format the case ID (brown/auburn color as in screenshot)
  const caseId = options.caseId || 'Unspecified';
  drawLabeledField('Case ID', caseId, '#993300', true); // Use true for bold
  
  // Format the date in the same style as the screenshot - "M/D/YYYY, h:mm:ss AM/PM"
  // Use user's timezone if provided, otherwise try to detect or use UTC
  let formattedDate = 'Unspecified';
  if (options.reportDate) {
    try {
      const reportDate = options.reportDate instanceof Date 
        ? options.reportDate 
        : new Date(options.reportDate);
      
      // Use provided timezone or default to America/Chicago (Central Time)
      const timezone = options.timezone || 'America/Chicago';
      
      // Format to match screenshot (6/14/2025, 11:27:25 AM) with correct timezone
      formattedDate = reportDate.toLocaleString('en-US', {
        timeZone: timezone,
        month: 'numeric',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        second: '2-digit',
        hour12: true
      });
    } catch (e) {
      console.warn('Error formatting date:', e);
      // Use the string value directly if there's an error parsing
      formattedDate = String(options.reportDate);
    }
  }
  drawLabeledField('Report Date', formattedDate);
  
  // Location (use the same location handling as above, ensuring it's human-readable)
  const location = options.location || 'Unknown Location';
  drawLabeledField('Location', location, '#996633'); // Brown color for location
  
  // Participants handling (convert array to string if needed)
  let formattedParticipants = 'None listed';
  if (options.participants) {
    if (Array.isArray(options.participants)) {
      formattedParticipants = options.participants.length > 0 
        ? options.participants.join(', ') 
        : 'None listed';
    } else {
      formattedParticipants = options.participants || 'None listed';
    }
  }
  drawLabeledField('Participants', formattedParticipants);
  
  // Relevance/Legal relevance 
  const relevance = options.relevance || options.legalRelevance || 'LEGAL';
  drawLabeledField('Relevance', relevance.toUpperCase());
  
  // Add minimal space after the formatted summary - reduce spacing to help fit more on first page
  yPos += lineHeight * 0.25;
  
  // Add section divider with reduced spacing
  addSectionDivider();
  
  // Check if we have both translated and original transcripts
  const hasOriginalTranscript = options.original_transcript && options.original_transcript.trim() !== '';
  const hasTranslatedTranscript = options.transcript || options.content;
  
  // Calculate height needed for transcript header and first few lines
  const minTranscriptHeight = lineHeight * 5; // Space for header + first few lines
  
  // Only add a new page if there's not enough space for the transcript header and a few lines
  // This ensures the transcript starts on page 1 whenever possible
  if (yPos + minTranscriptHeight > pageHeight - margin) {
    doc.addPage();
    yPos = margin;
  }
  
  // Add MAIN TRANSCRIPT section - this comes BEFORE the Spanish version
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(14);
  
  // If we have both transcripts, label appropriately based on languages
  // Get the detected/selected language from options
  const detectedLanguage = options.language || 'Unknown';
  
  // Use appropriate section headings
  if (hasOriginalTranscript && hasTranslatedTranscript) {
    // When we have both, show that this is the English translation
    doc.text(`ENGLISH TRANSLATION`, margin, yPos);
  } else {
    // Otherwise just show detected language
    doc.text(`TRANSCRIPT (${detectedLanguage})`, margin, yPos);
  }
  
  // Slightly reduced spacing after header
  yPos += lineHeight * 1.2;
  
  // Explicitly ensure Helvetica normal 12pt for plaintext rendering
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(12);
  
  // Get the transcript content from options.transcript
  // If options.transcript is not available, try to use options.content
  const transcriptContent = options.transcript || options.content || '';
  
  // CRITICAL: Log any naming issues in transcript fields
  console.log('ðŸ“‹ Transcript field name check:', {
    hasTranscriptField: 'transcript' in options,
    hasContentField: 'content' in options,
    hasOriginalTranscriptField: 'original_transcript' in options,
    fieldNames: Object.keys(options).filter(key => key.includes('transcript') || key.includes('content'))
  });
  
  // CRITICAL: Log full data to ensure transcript content is available
  console.log(`ðŸ” PDF Generation Data Check:`, {
    hasTranscript: !!options.transcript,
    hasContent: !!options.content,
    transcriptLength: transcriptContent.length,
    originalTranscriptLength: (options.original_transcript || '').length,
    language: options.language || 'Unknown'
  });
  
  // Debug output to verify transcript length
  console.log(`ðŸ—£ï¸ Transcript length: ${transcriptContent.length} characters`);
  if (transcriptContent.length > 5000) {
    console.log(`ðŸ—£ï¸ Large transcript detected (${transcriptContent.length} chars). First 100 chars: ${transcriptContent.substring(0, 100)}...`);
  }
  
  if (transcriptContent && transcriptContent.trim() !== '') {
    // Apply text sanitization to transcript content
    const transcriptText = sanitizeText(transcriptContent);
    
    // Split text to fit the available width
    const transcriptLines = doc.splitTextToSize(transcriptText, contentWidth);
    
    // ENHANCED pagination for potentially long transcript
    console.log(`ðŸ“„ Transcript has ${transcriptLines.length} lines to render`);
    
    if (transcriptLines.length > 0) {
      // Force a reasonable max height per page to ensure pagination
      const maxLinesPerPage = Math.floor((pageHeight - (margin * 2)) / lineHeight) - 5; // Subtract 5 for header/footer space
      console.log(`ðŸ“„ Maximum lines per page: ${maxLinesPerPage}`);
      
      let linesOnCurrentPage = 0;
      
      for (let i = 0; i < transcriptLines.length; i++) {
        // Force a new page if we've hit the maximum lines per page
        if (linesOnCurrentPage >= maxLinesPerPage || yPos > pageHeight - margin - lineHeight) {
          console.log(`ðŸ“„ Adding new page after ${linesOnCurrentPage} lines`);
          doc.addPage();
          yPos = margin;
          linesOnCurrentPage = 0;
          
          // Add "continued" indicator on new pages
          doc.setFont('helvetica', 'italic');
          doc.text('(continued)', margin, yPos);
          yPos += lineHeight * 1.5; // Extra space after continued indicator
          
          // Important: reset to normal font after indicator
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(12);
        }
        
        // Double check text is properly sanitized
        const safeText = sanitizeText(transcriptLines[i]);
        
        try {
          // Render each line with error handling
          doc.text(safeText, margin, yPos);
          yPos += lineHeight;
          linesOnCurrentPage++;
        } catch (err) {
          console.error(`ðŸ“„ Error rendering text line ${i}:`, err);
          // Try to continue with next line
        }
      }
      
      // Log completion stats
      console.log(`ðŸ“„ Finished rendering ${transcriptLines.length} lines across multiple pages`);
    } else {
      doc.text('No transcript available.', margin, yPos);
      yPos += lineHeight;
    }
  } else {
    doc.setFont('helvetica', 'italic');
    doc.text('No transcript available.', margin, yPos);
    yPos += lineHeight;
  }
  
  // Add section divider after main transcript
  addSectionDivider();
  
  // Now add the ORIGINAL TRANSCRIPT section if available
  if (hasOriginalTranscript) {
    // Always start on a new page for original transcript
    doc.addPage();
    yPos = margin;
    
    // Use consistent typography for section title
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(14);
    doc.text(`ORIGINAL TRANSCRIPT (${detectedLanguage})`, margin, yPos);
    yPos += lineHeight * 1.5;
    
    // Set to normal Helvetica for plaintext rendering
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    
    // Get the original transcript text and sanitize it
    const originalTranscript = sanitizeText(options.original_transcript || '');
    
    // Debug output for original transcript
    console.log(`ðŸ“ Original transcript length: ${originalTranscript.length} characters`);
    if (originalTranscript.length > 0) {
      console.log(`ðŸ“ Original transcript excerpt: ${originalTranscript.substring(0, 100)}...`);
    }
    
    // Split the text to fit the page width
    const originalLines = doc.splitTextToSize(originalTranscript, contentWidth);
    console.log(`ðŸ“„ Original transcript has ${originalLines.length} lines to render`);
    
    if (originalLines.length > 0) {
      // Enhanced pagination for potentially long original transcript
      const maxLinesPerPage = Math.floor((pageHeight - (margin * 2)) / lineHeight) - 5; // Subtract 5 for header/footer space
      console.log(`ðŸ“„ Maximum lines per page for original: ${maxLinesPerPage}`);
      
      let linesOnCurrentPage = 0;
      
      for (let i = 0; i < originalLines.length; i++) {
        // Force a new page if we've hit the maximum lines per page or approaching bottom margin
        if (linesOnCurrentPage >= maxLinesPerPage || yPos > pageHeight - margin - lineHeight) {
          console.log(`ðŸ“„ Adding new page after ${linesOnCurrentPage} lines (original transcript)`);
          doc.addPage();
          yPos = margin;
          linesOnCurrentPage = 0;
          
          // Add "continued" indicator on new pages
          doc.setFont('helvetica', 'italic');
          doc.text('(continued)', margin, yPos);
          yPos += lineHeight * 1.5; // Extra space after continued indicator
          
          // Reset to normal font after indicator
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(12);
        }
        
        // Double check text is properly sanitized
        const safeText = sanitizeText(originalLines[i]);
        
        try {
          // Render each line with error handling
          doc.text(safeText, margin, yPos);
          yPos += lineHeight;
          linesOnCurrentPage++;
        } catch (err) {
          console.error(`ðŸ“„ Error rendering original text line ${i}:`, err);
          // Try to continue with next line
        }
      }
      
      // Log completion stats
      console.log(`ðŸ“„ Finished rendering ${originalLines.length} lines of original transcript`);
    } else {
      doc.setFont('helvetica', 'italic');
      doc.text('No original transcript available.', margin, yPos);
      yPos += lineHeight;
    }
    
    // Add section divider after original transcript
    addSectionDivider();
  }
  
  // ============================================
  // FINAL VERIFICATION PAGE - QR Code & Signature
  // ============================================
  // Add a dedicated final page for verification artifacts
  // This keeps the report content clean and professional
  
  doc.addPage();
  let verifyY = margin;
  
  // Page header
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(18);
  doc.setTextColor(0, 0, 0);
  doc.text('VERIFICATION & EVIDENCE ACCESS', margin, verifyY);
  verifyY += lineHeight * 2;
  
  // Divider line
  doc.setDrawColor(200, 200, 200);
  doc.setLineWidth(1);
  doc.line(margin, verifyY, pageWidth - margin, verifyY);
  verifyY += lineHeight * 1.5;
  
  // Case ID section
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(12);
  doc.text(`Case ID: ${options.caseId || 'Unknown'}`, margin, verifyY);
  verifyY += lineHeight;
  
  // Timestamp
  const timestamp = new Date().toISOString();
  doc.text(`Generated: ${timestamp}`, margin, verifyY);
  verifyY += lineHeight * 2;
  
  // QR Code for video evidence (if available)
  if (options.videoUrl) {
    try {
      // Green branded block for video QR
      const blockWidth = 380;
      const blockHeight = 280;
      const blockX = (pageWidth - blockWidth) / 2;
      const blockY = verifyY;
      
      // Draw green background
      doc.setFillColor(39, 174, 96); // Green (#27AE60)
      doc.rect(blockX, blockY, blockWidth, blockHeight, 'F');
      
      // Title
      doc.setTextColor(255, 255, 255);
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(18);
      const title = 'SCAN TO WATCH EVIDENCE';
      const titleWidth = doc.getStringUnitWidth(title) * 18 / doc.internal.scaleFactor;
      doc.text(title, blockX + (blockWidth - titleWidth) / 2, blockY + 35);
      
      // Subtitle
      doc.setFontSize(12);
      doc.setFont('helvetica', 'normal');
      const friendlyUrl = `proof.ai/case/${options.caseId || 'unknown'}`;
      const subtitleText = `Or visit: ${friendlyUrl}`;
      const subtitleWidth = doc.getStringUnitWidth(subtitleText) * 12 / doc.internal.scaleFactor;
      doc.text(subtitleText, blockX + (blockWidth - subtitleWidth) / 2, blockY + 55);
      
      // QR Code with white background
      const qrSize = 150;
      const qrPadding = 20;
      const qrBgSize = qrSize + (qrPadding * 2);
      const qrBgX = blockX + (blockWidth - qrBgSize) / 2;
      const qrBgY = blockY + 75;
      
      doc.setFillColor(255, 255, 255);
      doc.rect(qrBgX, qrBgY, qrBgSize, qrBgSize, 'F');
      
      // Generate and add QR code
      const qrCodeDataURL = await QRCode.toDataURL(options.videoUrl, {
        errorCorrectionLevel: 'M',
        margin: 2,
        width: qrSize,
        color: { dark: '#000000', light: '#ffffff' },
      });
      
      doc.addImage(qrCodeDataURL, 'PNG', qrBgX + qrPadding, qrBgY + qrPadding, qrSize, qrSize);
      
      verifyY = blockY + blockHeight + lineHeight * 2;
      doc.setTextColor(0, 0, 0);
    } catch (error) {
      console.error('QR code generation failed:', error);
      doc.setTextColor(0, 0, 0);
      doc.text(`Video Evidence URL: ${options.videoUrl}`, margin, verifyY);
      verifyY += lineHeight * 2;
    }
  }
  
  // Digital signature placeholder
  if (options.includeSignature) {
    verifyY += lineHeight;
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(12);
    doc.text('AUTHORIZED SIGNATURE', margin, verifyY);
    verifyY += lineHeight * 1.5;
    
    // Signature line
    doc.setDrawColor(0);
    doc.setLineWidth(0.5);
    doc.line(margin, verifyY, margin + 200, verifyY);
    
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(10);
    doc.text('Signature', margin, verifyY + 15);
    doc.text('Date: _______________', margin + 220, verifyY);
    verifyY += lineHeight * 3;
  }
  
  // Verification QR code (smaller, bottom section)
  if (options.reportPublicUrl) {
    try {
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(11);
      doc.text('DOCUMENT VERIFICATION', margin, verifyY);
      verifyY += lineHeight;
      
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(10);
      doc.text('Scan to verify this document\'s authenticity:', margin, verifyY);
      verifyY += lineHeight * 1.5;
      
      const verifyQrSize = 80;
      const verifyQrDataURL = await QRCode.toDataURL(options.reportPublicUrl, {
        errorCorrectionLevel: 'H',
        margin: 1,
        width: verifyQrSize,
        color: { dark: '#000000', light: '#ffffff' },
      });
      
      doc.addImage(verifyQrDataURL, 'PNG', margin, verifyY, verifyQrSize, verifyQrSize);
      
      // Verification text beside QR
      doc.setFontSize(9);
      doc.text('Verify at: www.proof.ai', margin + verifyQrSize + 15, verifyY + 20);
      doc.text(`Report ID: ${options.caseId || 'Unknown'}`, margin + verifyQrSize + 15, verifyY + 35);
      doc.text('This document is timestamped and immutable.', margin + verifyQrSize + 15, verifyY + 50);
    } catch (error) {
      console.error('Verification QR code generation failed:', error);
    }
  }
  
  // Legal disclaimer at bottom
  doc.setFont('helvetica', 'italic');
  doc.setFontSize(8);
  doc.setTextColor(100, 100, 100);
  const disclaimer = 'This document was generated by ProofAI and serves as a record of the recorded evidence. The QR codes above provide direct access to the original video evidence and document verification.';
  const disclaimerLines = doc.splitTextToSize(disclaimer, contentWidth);
  doc.text(disclaimerLines, margin, pageHeight - 60);
  
  // Add page numbers to all pages
  addPageNumber();
  
  // Output the PDF as a Blob
  const pdfBlob = doc.output('blob');
  return pdfBlob;
}
