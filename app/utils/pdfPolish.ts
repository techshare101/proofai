import jsPDF from 'jspdf';
import 'jspdf-autotable';
import QRCode from 'qrcode';

interface PolishedPDFInput {
  title?: string;
  date?: Date | null;
  summary?: string | {
    text: string;
    structuredSummaryText?: string;
  };
  content: string;
  caseId: string;
  location?: string;
  url?: string;
  folderPath?: string;
  filename?: string;
  mimeType?: string;
  videoUrl: string;
  reportDate: string | Date;
  participants?: string | string[];
  relevance?: string;
  legalRelevance?: string; // Legal relevance information (legacy field)
  original_transcript?: string; // Original transcript in detected language
  reportPublicUrl?: string; // Public URL for report verification QR code
  includeSignature?: boolean; // Whether to include the signature placeholder
  transcript?: string; // Added to fix compatibility issues
  language?: string; // Language of the transcript
}

/**
 * Generates a professionally formatted PDF document with specified content and styling
 * @param options Input data for the PDF
 * @returns A Blob containing the generated PDF, ready for Supabase upload
 */
export async function generatePolishedPDF(options: PolishedPDFInput): Promise<Blob> {
  // Create a new PDF document with standard settings
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'pt',
    format: 'a4',
    // Adding Courier font which has better Unicode support
    putOnlyUsedFonts: true
  });
  
  // Add font that has better Unicode support
  doc.setFont('courier');
  
  // Set up document metadata for accessibility
  doc.setDocumentProperties({
    creator: 'ProofAI',
    title: `Case Report: ${options.caseId}`,
    subject: 'Transcript and Report Summary',
    keywords: 'ProofAI, Evidence, Legal',
    author: 'ProofAI System'
  });
  
  // Configure page margins and size
  const pageMargins = [40, 60, 40, 60]; // left, top, right, bottom
  // Page size is already set to A4 in jsPDF initialization
  
  // Document constants
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 50; // Margin in points
  const contentWidth = pageWidth - (margin * 2);
  
  // Typography settings
  doc.setFont('helvetica');
  doc.setFontSize(12);
  let lineHeight = 20; // ~1.5 line height at 12pt
  
  // Helper function to add page number and footer to each page
  const addPageNumber = () => {
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      
      // Add page numbers
      doc.setFont('helvetica');
      doc.setFontSize(10);
      doc.setTextColor(0, 0, 0); // Reset to black for page numbers
      const text = `Page ${i} of ${pageCount}`;
      const textWidth = doc.getStringUnitWidth(text) * 10 / doc.internal.scaleFactor;
      const textX = (pageWidth - textWidth) / 2;
      doc.text(text, textX, pageHeight - 25);
      
      // Add enhanced legal footer text in dark grey
      doc.setFontSize(9); // Reduced font size for legal footer
      doc.setTextColor(102, 102, 102); // Dark gray color (RGB: 102,102,102 or ~0.4,0.4,0.4)
      const footerText = 'Generated by ProofAI • www.proof.ai • This document is timestamped and immutable.';
      const footerWidth = doc.getStringUnitWidth(footerText) * 9 / doc.internal.scaleFactor; // Adjust for 9pt font
      const footerX = (pageWidth - footerWidth) / 2;
      doc.text(footerText, footerX, pageHeight - 15); // Position at y: 15 from bottom
    }
    
    // Reset text color after adding footers
    doc.setTextColor(0, 0, 0);
  };
  
  // Helper function to add section divider
  const addSectionDivider = () => {
    doc.setDrawColor(200);
    doc.line(margin, yPos, pageWidth - margin, yPos);
    yPos += lineHeight;
  };

  // Enhanced sanitize function for thoroughly removing emojis and special chars
  const sanitizeText = (text: string): string => {
    if (!text) return '';
    
    try {
      // Remove emoji characters - more comprehensive pattern
      const noEmoji = text.replace(/[\u{1F000}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F300}-\u{1F5FF}\u{1F900}-\u{1F9FF}\u{1F600}-\u{1F64F}\u{1F680}-\u{1F6FF}\u{2300}-\u{23FF}\u{2B50}\u{2B55}]/gu, '');
      
      // Remove other common symbols that might cause issues
      const noSymbols = noEmoji.replace(/[\u{1F1E0}-\u{1F1FF}\u{2702}-\u{27B0}\u{24C2}-\u{1F251}\u{1F004}\u{1F0CF}]/gu, '');
      
      // Remove control characters and other special encoding characters
      const noControlChars = noSymbols.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
      
      // Clean up other potential problematic characters
      const cleaned = noControlChars
        // Replace fancy quotes with regular quotes
        .replace(/[\u{201C}\u{201D}\u{2018}\u{2019}]/gu, '"')
        // Replace other special whitespace
        .replace(/[\u{2002}-\u{200D}\u{2060}\u{FEFF}]/gu, ' ')
        // Remove multiple consecutive spaces
        .replace(/\s+/g, ' ');
      
      // Normalize the text using NFC
      return cleaned.normalize('NFC');
    } catch (e) {
      console.warn('Failed to sanitize text:', e);
      // Fallback: strip non-ASCII characters
      return text.replace(/[^\x20-\x7E]/g, '');
    }
  };

  // Start position for content
  let yPos = margin;

  // Add CASE REPORT header
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('CASE REPORT', margin, yPos);
  yPos += lineHeight * 1.5;
  
  // Add location metadata (using geocoded address if available)
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(12);
  
  // Format the location to ensure it's human readable
  let displayLocation = sanitizeText(options.location || 'Unknown Location');
  
  // In case the location still contains lat/lng format after all our efforts
  if (displayLocation.startsWith('Lat:') || displayLocation.includes(',') && /[\d]+\.[\d]+/.test(displayLocation)) {
    displayLocation = 'Location information available but not geocoded';
  }
  
  // Display the location
  doc.text(`Location: ${displayLocation}`, margin, yPos);
  yPos += lineHeight * 2;
  
  // Set up monospaced font for the structured summary section
  doc.setFont('courier', 'normal');
  doc.setFontSize(12);
  
  // Format participants (convert array to string if needed and handle empty case)
  let participantsText = 'None listed';
  if (options.participants) {
    if (Array.isArray(options.participants) && options.participants.length > 0) {
      participantsText = sanitizeText(options.participants.join(', '));
    } else if (typeof options.participants === 'string' && options.participants.trim() !== '') {
      participantsText = sanitizeText(options.participants);
    }
  }
  
  // Skip the duplicate summary block entirely
  // Only keep the location at the top of the page
  
  // Add extra space before the structured summary section
  yPos += lineHeight * 0.5;
  
  // Add a visual divider for the structured summary section
  doc.setDrawColor(200, 200, 200);
  doc.setLineWidth(0.5);
  doc.line(margin, yPos, pageWidth - margin, yPos);
  yPos += lineHeight * 0.5;
  
  // Draw the REPORT SUMMARY section header - no emoji
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(14);
  doc.text('REPORT SUMMARY', margin, yPos);
  
  // Add a dashed line after the header
  yPos += lineHeight * 0.75;
  doc.setDrawColor(128, 128, 128); // Gray
  doc.setLineWidth(0.5);
  doc.setLineDashPattern([2, 2], 0); // Dashed line
  doc.line(margin, yPos, margin + 250, yPos);
  doc.setLineDashPattern([10, 0], 0); // Reset to solid line
  doc.setDrawColor(0); // Reset to black
  
  yPos += lineHeight * 1.2;
  
  // Function to draw a field with proper formatting
  const drawLabeledField = (label: string, value: string, color: string = '#000000', isBold: boolean = false) => {
    // Sanitize value to ensure clean rendering
    const sanitizedValue = sanitizeText(value || '');
    
    // Format label with proper styling
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(102, 0, 153); // Purple for labels - similar to 'SUMMARY' text in screenshot
    doc.text(`${label}:`, margin, yPos);
    
    // Set style for value
    doc.setFont('helvetica', isBold ? 'bold' : 'normal');
    
    // Set text color based on field - convert hex to RGB
    const r = parseInt(color.substring(1, 3), 16);
    const g = parseInt(color.substring(3, 5), 16);
    const b = parseInt(color.substring(5, 7), 16);
    doc.setTextColor(r, g, b);
    
    // Calculate offset for value (after label)
    const labelWidth = doc.getStringUnitWidth(`${label}: `) * doc.getFontSize() / doc.internal.scaleFactor;
    const xOffset = margin + labelWidth + 5;
    
    // Handle value possibly wrapping
    if (sanitizedValue.length > 50) {
      const lines = doc.splitTextToSize(sanitizedValue, pageWidth - xOffset - margin);
      doc.text(lines, xOffset, yPos);
      yPos += lineHeight * Math.max(1, lines.length * 0.8);
    } else {
      doc.text(sanitizedValue, xOffset, yPos);
      yPos += lineHeight;
    }
    
    // Reset text color to black
    doc.setTextColor(0, 0, 0);
  };
  
  // Extract and format the case ID (brown/auburn color as in screenshot)
  const caseId = options.caseId || 'Unspecified';
  drawLabeledField('Case ID', caseId, '#993300', true); // Use true for bold
  
  // Format the date in the same style as the screenshot - "M/D/YYYY, h:mm:ss AM/PM"
  let formattedDate = 'Unspecified';
  if (options.reportDate) {
    try {
      const reportDate = options.reportDate instanceof Date 
        ? options.reportDate 
        : new Date(options.reportDate);
      
      // Format to match screenshot (6/14/2025, 11:27:25 AM)
      formattedDate = reportDate.toLocaleString('en-US', {
        month: 'numeric',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        second: '2-digit',
        hour12: true
      });
    } catch (e) {
      console.warn('Error formatting date:', e);
      // Use the string value directly if there's an error parsing
      formattedDate = String(options.reportDate);
    }
  }
  drawLabeledField('Report Date', formattedDate);
  
  // Location (use the same location handling as above, ensuring it's human-readable)
  const location = options.location || 'Unknown Location';
  drawLabeledField('Location', location, '#996633'); // Brown color for location
  
  // Participants handling (convert array to string if needed)
  let formattedParticipants = 'None listed';
  if (options.participants) {
    if (Array.isArray(options.participants)) {
      formattedParticipants = options.participants.length > 0 
        ? options.participants.join(', ') 
        : 'None listed';
    } else {
      formattedParticipants = options.participants || 'None listed';
    }
  }
  drawLabeledField('Participants', formattedParticipants);
  
  // Relevance/Legal relevance 
  const relevance = options.relevance || options.legalRelevance || 'LEGAL';
  drawLabeledField('Relevance', relevance.toUpperCase());
  
  // Add minimal space after the formatted summary - reduce spacing to help fit more on first page
  yPos += lineHeight * 0.25;
  
  // Add section divider with reduced spacing
  addSectionDivider();
  
  // Check if we have both translated and original transcripts
  const hasOriginalTranscript = options.original_transcript && options.original_transcript.trim() !== '';
  const hasTranslatedTranscript = options.transcript || options.content;
  
  // Calculate height needed for transcript header and first few lines
  const minTranscriptHeight = lineHeight * 5; // Space for header + first few lines
  
  // Only add a new page if there's not enough space for the transcript header and a few lines
  // This ensures the transcript starts on page 1 whenever possible
  if (yPos + minTranscriptHeight > pageHeight - margin) {
    doc.addPage();
    yPos = margin;
  }
  
  // Add MAIN TRANSCRIPT section - this comes BEFORE the Spanish version
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(14);
  
  // If we have both transcripts, label appropriately based on languages
  // Get the detected/selected language from options
  const detectedLanguage = options.language || 'Unknown';
  
  // Use appropriate section headings
  if (hasOriginalTranscript && hasTranslatedTranscript) {
    // When we have both, show that this is the English translation
    doc.text(`ENGLISH TRANSLATION`, margin, yPos);
  } else {
    // Otherwise just show detected language
    doc.text(`TRANSCRIPT (${detectedLanguage})`, margin, yPos);
  }
  
  // Slightly reduced spacing after header
  yPos += lineHeight * 1.2;
  
  // Explicitly ensure Helvetica normal 12pt for plaintext rendering
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(12);
  
  // Get the transcript content from options.transcript
  // If options.transcript is not available, try to use options.content
  const transcriptContent = options.transcript || options.content || '';
  
  // CRITICAL: Log any naming issues in transcript fields
  console.log('📋 Transcript field name check:', {
    hasTranscriptField: 'transcript' in options,
    hasContentField: 'content' in options,
    hasOriginalTranscriptField: 'original_transcript' in options,
    fieldNames: Object.keys(options).filter(key => key.includes('transcript') || key.includes('content'))
  });
  
  // CRITICAL: Log full data to ensure transcript content is available
  console.log(`🔍 PDF Generation Data Check:`, {
    hasTranscript: !!options.transcript,
    hasContent: !!options.content,
    transcriptLength: transcriptContent.length,
    originalTranscriptLength: (options.original_transcript || '').length,
    language: options.language || 'Unknown'
  });
  
  // Debug output to verify transcript length
  console.log(`🗣️ Transcript length: ${transcriptContent.length} characters`);
  if (transcriptContent.length > 5000) {
    console.log(`🗣️ Large transcript detected (${transcriptContent.length} chars). First 100 chars: ${transcriptContent.substring(0, 100)}...`);
  }
  
  if (transcriptContent && transcriptContent.trim() !== '') {
    // Apply text sanitization to transcript content
    const transcriptText = sanitizeText(transcriptContent);
    
    // Split text to fit the available width
    const transcriptLines = doc.splitTextToSize(transcriptText, contentWidth);
    
    // ENHANCED pagination for potentially long transcript
    console.log(`📄 Transcript has ${transcriptLines.length} lines to render`);
    
    if (transcriptLines.length > 0) {
      // Force a reasonable max height per page to ensure pagination
      const maxLinesPerPage = Math.floor((pageHeight - (margin * 2)) / lineHeight) - 5; // Subtract 5 for header/footer space
      console.log(`📄 Maximum lines per page: ${maxLinesPerPage}`);
      
      let linesOnCurrentPage = 0;
      
      for (let i = 0; i < transcriptLines.length; i++) {
        // Force a new page if we've hit the maximum lines per page
        if (linesOnCurrentPage >= maxLinesPerPage || yPos > pageHeight - margin - lineHeight) {
          console.log(`📄 Adding new page after ${linesOnCurrentPage} lines`);
          doc.addPage();
          yPos = margin;
          linesOnCurrentPage = 0;
          
          // Add "continued" indicator on new pages
          doc.setFont('helvetica', 'italic');
          doc.text('(continued)', margin, yPos);
          yPos += lineHeight * 1.5; // Extra space after continued indicator
          
          // Important: reset to normal font after indicator
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(12);
        }
        
        // Double check text is properly sanitized
        const safeText = sanitizeText(transcriptLines[i]);
        
        try {
          // Render each line with error handling
          doc.text(safeText, margin, yPos);
          yPos += lineHeight;
          linesOnCurrentPage++;
        } catch (err) {
          console.error(`📄 Error rendering text line ${i}:`, err);
          // Try to continue with next line
        }
      }
      
      // Log completion stats
      console.log(`📄 Finished rendering ${transcriptLines.length} lines across multiple pages`);
    } else {
      doc.text('No transcript available.', margin, yPos);
      yPos += lineHeight;
    }
  } else {
    doc.setFont('helvetica', 'italic');
    doc.text('No transcript available.', margin, yPos);
    yPos += lineHeight;
  }
  
  // Add section divider after main transcript
  addSectionDivider();
  
  // Now add the ORIGINAL TRANSCRIPT section if available
  if (hasOriginalTranscript) {
    // Always start on a new page for original transcript
    doc.addPage();
    yPos = margin;
    
    // Use consistent typography for section title
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(14);
    doc.text(`ORIGINAL TRANSCRIPT (${detectedLanguage})`, margin, yPos);
    yPos += lineHeight * 1.5;
    
    // Set to normal Helvetica for plaintext rendering
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    
    // Get the original transcript text and sanitize it
    const originalTranscript = sanitizeText(options.original_transcript || '');
    
    // Debug output for original transcript
    console.log(`📝 Original transcript length: ${originalTranscript.length} characters`);
    if (originalTranscript.length > 0) {
      console.log(`📝 Original transcript excerpt: ${originalTranscript.substring(0, 100)}...`);
    }
    
    // Split the text to fit the page width
    const originalLines = doc.splitTextToSize(originalTranscript, contentWidth);
    console.log(`📄 Original transcript has ${originalLines.length} lines to render`);
    
    if (originalLines.length > 0) {
      // Enhanced pagination for potentially long original transcript
      const maxLinesPerPage = Math.floor((pageHeight - (margin * 2)) / lineHeight) - 5; // Subtract 5 for header/footer space
      console.log(`📄 Maximum lines per page for original: ${maxLinesPerPage}`);
      
      let linesOnCurrentPage = 0;
      
      for (let i = 0; i < originalLines.length; i++) {
        // Force a new page if we've hit the maximum lines per page or approaching bottom margin
        if (linesOnCurrentPage >= maxLinesPerPage || yPos > pageHeight - margin - lineHeight) {
          console.log(`📄 Adding new page after ${linesOnCurrentPage} lines (original transcript)`);
          doc.addPage();
          yPos = margin;
          linesOnCurrentPage = 0;
          
          // Add "continued" indicator on new pages
          doc.setFont('helvetica', 'italic');
          doc.text('(continued)', margin, yPos);
          yPos += lineHeight * 1.5; // Extra space after continued indicator
          
          // Reset to normal font after indicator
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(12);
        }
        
        // Double check text is properly sanitized
        const safeText = sanitizeText(originalLines[i]);
        
        try {
          // Render each line with error handling
          doc.text(safeText, margin, yPos);
          yPos += lineHeight;
          linesOnCurrentPage++;
        } catch (err) {
          console.error(`📄 Error rendering original text line ${i}:`, err);
          // Try to continue with next line
        }
      }
      
      // Log completion stats
      console.log(`📄 Finished rendering ${originalLines.length} lines of original transcript`);
    } else {
      doc.setFont('helvetica', 'italic');
      doc.text('No original transcript available.', margin, yPos);
      yPos += lineHeight;
    }
    
    // Add section divider after original transcript
    addSectionDivider();
  }
  
  // Add QR code for video URL if available
  if (options.videoUrl) {
    try {
      // Create a branded visual CTA block with green background
      
      // First, ensure we have enough space for the CTA block
      const ctaBlockHeight = 200; // Height of the entire CTA block
      
      // Add a new page if needed to ensure enough space
      if (yPos + ctaBlockHeight > pageHeight - margin) {
        doc.addPage();
        yPos = margin + 20; // Start slightly lower on the new page
      } else {
        yPos += lineHeight * 2; // Add spacing before the CTA block
      }
      
      // COMPLETE REDESIGN OF QR SECTION - VERTICAL LAYOUT WITH CLEAR SEPARATION
      
      // Calculate block dimensions - using vertical layout with more height
      const blockWidth = 400; // Width of the green block
      const blockHeight = 320; // Increased height to prevent overlap (from 280px)
      const blockX = (pageWidth - blockWidth) / 2; // Center horizontally
      const blockY = yPos;
      
      // Draw green background rectangle
      doc.setFillColor(39, 174, 96); // Green color (#27AE60)
      doc.rect(blockX, blockY, blockWidth, blockHeight, 'F');
      
      // TEXT SECTION - All text at the top of the block
      // Set up text styles
      doc.setTextColor(255, 255, 255); // White text
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(20); // Larger text
      
      // Add the title centered at the top with more space
      const title = 'SCAN TO WATCH EVIDENCE';
      const titleWidth = doc.getStringUnitWidth(title) * 20 / doc.internal.scaleFactor;
      const titleX = blockX + (blockWidth - titleWidth) / 2;
      const titleY = blockY + 35; // Good space from top
      doc.text(title, titleX, titleY);
      
      // Add the subtitle with case ID
      const caseId = options.caseId || 'unknown';
      const friendlyUrl = `proof.ai/case/${caseId}`;
      doc.setFontSize(14);
      doc.setFont('helvetica', 'normal');
      const subtitleText = 'Or visit:';
      const subtitleWidth = doc.getStringUnitWidth(subtitleText) * 14 / doc.internal.scaleFactor;
      const subtitleX = blockX + (blockWidth - subtitleWidth - doc.getStringUnitWidth(friendlyUrl) * 14 / doc.internal.scaleFactor - 5) / 2;
      const subtitleY = titleY + 30;
      doc.text(subtitleText, subtitleX, subtitleY);
      
      // Add the URL beside "Or visit:"
      doc.setFont('helvetica', 'bold');
      doc.text(friendlyUrl, subtitleX + subtitleWidth + 5, subtitleY);
      
      // QR CODE SECTION - Positioned below text with proper spacing
      // Create white background for QR code with extra generous quiet zone
      const qrPadding = 25; // Slightly adjusted padding (from 30px)
      const qrSize = 160; // Slightly reduced size (from 180px) but still larger than original
      const qrBackgroundSize = qrSize + (qrPadding * 2); // QR size + padding on each side
      
      // Calculate position for QR below the text with fixed spacing
      // This ensures no overlap while maintaining scannability
      const qrVerticalOffset = 80; // Fixed space below subtitle
      const qrBackgroundX = blockX + (blockWidth - qrBackgroundSize) / 2; // Horizontally centered
      const qrBackgroundY = subtitleY + qrVerticalOffset; // Fixed position below text
      
      // Draw white background for QR (larger with more padding)
      doc.setFillColor(255, 255, 255);
      doc.rect(qrBackgroundX, qrBackgroundY, qrBackgroundSize, qrBackgroundSize, 'F');
      
      // Create QR code matching the screenshot style:
      // - Medium error correction for balance of error correction and block size
      // - Sharp edges and distinct blocks
      // - Clean, classic QR pattern
      const qrCodeDataURL = await QRCode.toDataURL(options.videoUrl, {
        errorCorrectionLevel: 'M', // Medium error correction for balance
        margin: 2, // Smaller margin to match screenshot style
        width: qrSize, // Maintained large size
        rendererOpts: {
          quality: 1.0, // Maximum quality
        },
        scale: 8, // Increase scale for sharper edges
        color: {
          dark: '#000000', // Pure black
          light: '#ffffff', // Pure white
        },
      });
      
      // Add the QR code centered in the white background
      const qrX = qrBackgroundX + qrPadding;
      const qrY = qrBackgroundY + qrPadding;
      doc.addImage(qrCodeDataURL, 'PNG', qrX, qrY, qrSize, qrSize);
      
      // Update yPos to the end of the block
      yPos += blockHeight + lineHeight * 2;
      
      // Reset text color for rest of document
      doc.setTextColor(0, 0, 0);
    } catch (error) {
      // Handle any errors in QR code generation
      doc.setTextColor(0, 0, 0); // Reset text color
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(12);
      doc.text('Error generating QR code for video evidence.', margin, yPos);
      yPos += lineHeight;
      
      // Display the URL as text in case QR code fails
      if (options.videoUrl) {
        doc.text(`Video URL: ${options.videoUrl}`, margin, yPos);
      }
      
      console.error('QR code generation failed:', error);
    }
  }
  
  // Navigate to the last page for adding the signature and verification QR code
  doc.setPage(doc.getNumberOfPages());
  
  // Add digital signature placeholder if includeSignature is true
  if (options.includeSignature) {
    const signatureY = pageHeight - 80;
    
    // Add signature line
    doc.setDrawColor(0);
    doc.line(60, signatureY, 260, signatureY);
    
    // Add signature text
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(10);
    doc.text('Authorized Signature', 60, signatureY + 15);
  }
  
  // Add verification QR code if reportPublicUrl is available
  if (options.reportPublicUrl) {
    try {
      // Set position for QR code (bottom-right corner)
      const qrSize = 80;
      const qrX = pageWidth - 100; // 100px from right edge
      const qrY = pageHeight - 40 - qrSize; // 40px from bottom edge
      
      // Generate QR code with high error correction
      const qrCodeDataURL = await QRCode.toDataURL(options.reportPublicUrl, {
        errorCorrectionLevel: 'H', // Highest error correction
        margin: 1,
        width: qrSize,
        color: {
          dark: '#000000',
          light: '#ffffff',
        },
      });
      
      // Add the QR code to the PDF
      doc.addImage(qrCodeDataURL, 'PNG', qrX, qrY, qrSize, qrSize);
      
      // Add verification caption
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(8);
      const captionText = 'Verify at www.proof.ai';
      const captionWidth = doc.getStringUnitWidth(captionText) * 8 / doc.internal.scaleFactor;
      doc.text(captionText, qrX + (qrSize - captionWidth) / 2, qrY + qrSize + 10);
    } catch (error) {
      console.error('Verification QR code generation failed:', error);
    }
  }
  
  // Add page numbers to all pages
  addPageNumber();
  
  // Output the PDF as a Blob
  const pdfBlob = doc.output('blob');
  return pdfBlob;
}
