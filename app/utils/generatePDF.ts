import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
import { PdfGenerationOptions } from '../types/pdf';

interface PdfRequest {
  content: string;
  caseId: string;
  generatedBy?: string;
  options: PdfGenerationOptions;
}

interface Section {
  title: string;
  content: string;
}

const DEFAULT_OPTIONS: PdfGenerationOptions = {
  watermark: false,
  confidential: true,
  includeSignature: true,
  includeTimestamps: true,
  includeFooter: true
};

import { StructuredSummary } from '../types/pdf';
import { formatSummary } from './formatSummary';

export async function generatePDF(request: PdfRequest): Promise<Uint8Array> {
  const { options = DEFAULT_OPTIONS, caseId, generatedBy = 'ProofAI', structuredSummary } = request;
  try {
    // Create PDF document
    const doc = await PDFDocument.create();
    const page = doc.addPage();
    const { width, height } = page.getSize();
    const margin = 50;
    let y = height - margin;

    // Load font
    const font = await doc.embedFont(StandardFonts.Helvetica);
    const boldFont = await doc.embedFont(StandardFonts.HelveticaBold);

    // Header Section
    page.drawText('PROOF AI INCIDENT REPORT', {
      x: width / 2 - boldFont.widthOfTextAtSize('PROOF AI INCIDENT REPORT', 24) / 2,
      y: y,
      font: boldFont,
      size: 24
    });
    y -= 30;

    if (options.confidential) {
      page.drawText('CONFIDENTIAL', {
        x: width / 2 - font.widthOfTextAtSize('CONFIDENTIAL', 12) / 2,
        y: y,
        font: font,
        size: 12,
        color: rgb(1, 0, 0)
      });
      y -= 30;
    }

    // Metadata
    const metaSections = [
      { title: 'Case ID', content: structuredSummary.caseId },
      { title: 'Timestamp', content: new Date(structuredSummary.reportDate).toLocaleString() },
      { title: 'Generated By', content: generatedBy },
      { title: 'Location', content: structuredSummary.location || 'Not specified' }
    ];
    for (const section of metaSections) {
      page.drawText(section.title + ':', {
        x: margin,
        y: y,
        font: boldFont,
        size: 12
      });
      page.drawText(section.content, {
        x: margin + 140,
        y: y,
        font: font,
        size: 12
      });
      y -= 20;
    }
    y -= 10;

    // Main Content Section
    page.drawText('Report:', {
      x: margin,
      y: y,
      font: boldFont,
      size: 14
    });
    y -= 20;
    const contentText = request.content || '';
    const contentLines = contentText.split('\n');
    for (const line of contentLines) {
      page.drawText(line, {
        x: margin,
        y: y,
        font: font,
        size: 12
      });
      y -= 15;
    }
    y -= 10;

    // Flags (Legal Relevance, Confidentiality, Signature Required)
    let flags = '';
    if (structuredSummary.reportRelevance?.legal) flags += 'Legal Relevance  ';
    if (options.confidential) flags += 'Confidential  ';
    if (options.includeSignature) flags += 'Signature Required';
    if (flags) {
      page.drawText(flags, {
        x: margin,
        y: y,
        font: font,
        size: 11,
        color: rgb(0, 0.2, 0.6)
      });
      y -= 18;
    }
    y -= 5;

    // Transcript Section
    page.drawText('Transcript:', {
      x: margin,
      y: y,
      font: boldFont,
      size: 14
    });
    y -= 20;
    // Extract transcript fields from structuredSummary or request
    const originalTranscript = structuredSummary.originalTranscript || request.originalTranscript || '';
    const translatedTranscript = structuredSummary.translatedTranscript || request.translatedTranscript || '';
    const transcript = structuredSummary.transcript || request.transcript || translatedTranscript || originalTranscript || '';
    const transcriptLines: string[] = [];
    if (originalTranscript && translatedTranscript && originalTranscript !== translatedTranscript) {
      transcriptLines.push('Original:');
      transcriptLines.push(...originalTranscript.split('\n'));
      transcriptLines.push('--- Translation:');
      transcriptLines.push(...translatedTranscript.split('\n'));
    } else if (translatedTranscript) {
      transcriptLines.push(...translatedTranscript.split('\n'));
    } else if (transcript) {
      transcriptLines.push(...transcript.split('\n'));
    }
    // Format lines as "HH:mm:ss — transcript line" if timestampedLog exists
    if (structuredSummary.timestampedLog?.length) {
      for (const log of structuredSummary.timestampedLog) {
        page.drawText(log, {
          x: margin + 10,
          y: y,
          font: font,
          size: 11
        });
        y -= 13;
      }
    } else {
      for (const line of transcriptLines) {
        page.drawText(line, {
          x: margin + 10,
          y: y,
          font: font,
          size: 11
        });
        y -= 13;
      }
    }
    y -= 10;

    // Key Observations / Events
    if (structuredSummary.keyEvents?.length) {
      page.drawText('Key Observations / Events:', {
        x: margin,
        y: y,
        font: boldFont,
        size: 14
      });
      y -= 20;
      for (const event of structuredSummary.keyEvents) {
        page.drawText('• ' + event, {
          x: margin + 10,
          y: y,
          font: font,
          size: 12
        });
        y -= 15;
      }
      y -= 5;
    }

    // Participants
    if (structuredSummary.participants?.length) {
      page.drawText('Participants:', {
        x: margin,
        y: y,
        font: boldFont,
        size: 14
      });
      y -= 20;
      for (const participant of structuredSummary.participants) {
        page.drawText('• ' + participant, {
          x: margin + 10,
          y: y,
          font: font,
          size: 12
        });
        y -= 15;
      }
      y -= 5;
    }

    // Footer
    let footerText = `Generated by ProofAI – Immutable Report ID: ${structuredSummary.caseId}`;
    if (options.includeSignature) {
      y -= 25;
      page.drawText('Signature: ___________________________', {
        x: margin,
        y: y,
        font: font,
        size: 12
      });
      y -= 20;
    }
    page.drawText(footerText, {
      x: width / 2 - font.widthOfTextAtSize(footerText, 10) / 2,
      y: margin,
      font: font,
      size: 10,
      color: rgb(0.5, 0.5, 0.5)
    });

    // Save document
    return await doc.save();
  } catch (error) {
    console.error('PDF generation error:', error);
    throw error;
  }
}

