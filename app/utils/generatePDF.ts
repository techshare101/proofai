import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
import { PdfGenerationOptions } from '../types/pdf';

interface PdfRequest {
  content: string;
  caseId: string;
  generatedBy?: string;
  options: PdfGenerationOptions;
  structuredSummary?: StructuredSummary;
}

interface Section {
  title: string;
  content: string;
}

const DEFAULT_OPTIONS: PdfGenerationOptions = {
  watermark: false,
  confidential: true,
  includeSignature: true,
  includeTimestamps: true,
  includeFooter: true
};

import { StructuredSummary } from '../types/pdf';
import { formatSummary } from './formatSummary';

// Utility to strip emojis from text for PDF safety
function sanitizeText(text: string): string {
  return text
    .replace('üìÑ', '[Report]')
    .replace('üè∑Ô∏è', '[Relevance]')
    .replace('üë•', '[Participants]')
    .replace('üÜî', '[ID]')
    .replace('üìÖ', '[Date]')
    .replace('üìç', '[Location]')
    .replace(/\p{Emoji_Presentation}/gu, ''); // fallback to strip any remaining emojis
}

export async function generatePDF(request: PdfRequest): Promise<Uint8Array> {
  const { options = DEFAULT_OPTIONS, caseId, generatedBy = 'ProofAI', structuredSummary } = request;
  try {
    // Create PDF document
    const pdfDoc = await PDFDocument.create();
    let page = pdfDoc.addPage();
    const { width, height } = page.getSize();

    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    const fontSize = 12;
    let y = height - 50;

    // Apply emoji-safe sanitation
    const cleanedSummary = sanitizeText(structuredSummary.summary || '');
    const cleanedTranscript = sanitizeText(structuredSummary.transcript || '');
    const cleanedOriginal = sanitizeText(structuredSummary.originalTranscript || '');
    const cleanedLocation = sanitizeText(structuredSummary.location || '');
    const cleanedCaseId = sanitizeText(structuredSummary.caseId || '');
    const cleanedDate = sanitizeText(structuredSummary.reportDate || '');

    // Title (bold, centered)
    const title = 'PROOF AI INCIDENT REPORT';
    page.drawText(title, {
      x: width / 2 - boldFont.widthOfTextAtSize(title, 18) / 2,
      y,
      size: 18,
      font: boldFont,
      color: rgb(0, 0, 0)
    });
    y -= 18 + 8;

    // Horizontal line under title
    page.drawLine({
      start: { x: 50, y: y },
      end: { x: width - 50, y: y },
      thickness: 1,
      color: rgb(0.1, 0.1, 0.1)
    });
    y -= 18;

    // Metadata (normal font)
    page.drawText(`Case ID: ${cleanedCaseId}`, { x: 50, y, size: fontSize, font, color: rgb(0, 0, 0) });
    y -= 16;
    page.drawText(`Report Date: ${new Date(cleanedDate).toLocaleString()}`, { x: 50, y, size: fontSize, font, color: rgb(0, 0, 0) });
    y -= 16;
    page.drawText(`Location: ${cleanedLocation}`, { x: 50, y, size: fontSize, font, color: rgb(0, 0, 0) });
    y -= 16;
    page.drawText(`Generated By: ${generatedBy}`, { x: 50, y, size: fontSize, font, color: rgb(0, 0, 0) });
    y -= 24;

    // Section: Summary
    page.drawText('Summary:', { x: 50, y, size: 14, font: boldFont, color: rgb(0.1, 0.1, 0.5) });
    y -= 18;
    for (const line of cleanedSummary.split('\n')) {
      page.drawText(line, { x: 60, y, size: fontSize, font, color: rgb(0, 0, 0) });
      y -= 16;
      if (y < 50) { y = height - 50; page = pdfDoc.addPage(); }
    }
    y -= 10;

    // Section: Transcript
    page.drawText('Transcript:', { x: 50, y, size: 14, font: boldFont, color: rgb(0.1, 0.1, 0.5) });
    y -= 18;
    for (const line of cleanedTranscript.split('\n')) {
      page.drawText(line, { x: 60, y, size: fontSize, font, color: rgb(0, 0, 0) });
      y -= 16;
      if (y < 50) { y = height - 50; page = pdfDoc.addPage(); }
    }
    y -= 10;

    // Section: Original Transcript
    page.drawText('Original Transcript:', { x: 50, y, size: 14, font: boldFont, color: rgb(0.1, 0.1, 0.5) });
    y -= 18;
    for (const line of cleanedOriginal.split('\n')) {
      page.drawText(line, { x: 60, y, size: fontSize, font, color: rgb(0, 0, 0) });
      y -= 16;
      if (y < 50) { y = height - 50; page = pdfDoc.addPage(); }
    }

    const pdfBytes = await pdfDoc.save();
    console.log('[generatePDF] Byte length of final PDF:', pdfBytes.length);
    return pdfBytes;
  } catch (error) {
    console.error('PDF generation error:', error);
    throw error;
  }
}
