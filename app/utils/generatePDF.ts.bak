import { PDFDocument, StandardFonts, rgb, PDFPage } from 'pdf-lib';
import QRCode from 'qrcode';

/**
 * Helper function to split text into lines based on width constraints
 * This ensures text properly wraps and doesn't overflow the page
 */
function splitTextIntoLines(text: string, font: any, fontSize: number, maxWidth: number): string[] {
  if (!text) return [''];
  
  const words = text.split(' ');
  const lines: string[] = [];
  let currentLine = '';

  for (const word of words) {
    const potentialLine = currentLine ? `${currentLine} ${word}` : word;
    const width = font.widthOfTextAtSize(potentialLine, fontSize);

    if (width <= maxWidth) {
      currentLine = potentialLine;
    } else {
      lines.push(currentLine);
      currentLine = word;
    }
  }

  if (currentLine) {
    lines.push(currentLine);
  }

  return lines;
}

/**
 * Helper to draw underlined section headers
 */
function drawSectionHeader(page: PDFPage, text: string, x: number, y: number, size: number, font: any): number {
  page.drawText(text, { x, y, size, font });
  
  // Draw underline
  const textWidth = font.widthOfTextAtSize(text, size);
  page.drawLine({
    start: { x, y: y - 3 },
    end: { x: x + textWidth, y: y - 3 },
    thickness: 1,
    color: rgb(0, 0, 0),
  });
  
  return y - 20; // Return the next Y position
}

/**
 * Add a footer to a PDF page
 */
function addFooter(page: PDFPage, pageNum: number, totalPages: number, font: any, pageWidth: number, margin: number): void {
  // Page number at bottom
  const footerText = `Page ${pageNum}/${totalPages}`;
  const textWidth = font.widthOfTextAtSize(footerText, 10);
  
  page.drawText(footerText, {
    x: (pageWidth - textWidth) / 2,
    y: 30,
    size: 10,
    color: rgb(0, 0, 0),
    font,
  });
  
  // Company info - exact text from requirements
  const companyText = 'Generated by ProofAI â€¢ Confidential & Secure';
  const companyTextWidth = font.widthOfTextAtSize(companyText, 8);
  
  page.drawText(companyText, {
    x: (pageWidth - companyTextWidth) / 2,
    y: 15,
    size: 8,
    color: rgb(0.5, 0.5, 0.5),
    font,
  });
  
  // Footer line
  page.drawLine({
    start: { x: margin, y: 50 },
    end: { x: pageWidth - margin, y: 50 },
    thickness: 1,
    color: rgb(0.7, 0.7, 0.7),
  });
}

/**
 * Add a header to a PDF page
 */
function addHeader(page: PDFPage, location: string, font: any, boldFont: any, margin: number, pageWidth: number): void {
  // CASE REPORT text in bold, uppercase
  page.drawText('CASE REPORT', { 
    x: margin, 
    y: 780, 
    size: 16, 
    font: boldFont 
  });

  // Location line below header
  page.drawText(`LOCATION: ${location}`, { 
    x: margin, 
    y: 760, 
    size: 10, 
    font: font,
    color: rgb(0.4, 0.4, 0.4) // Dark gray
  });

  // Divider line below header
  page.drawLine({
    start: { x: margin, y: 750 },
    end: { x: pageWidth - margin, y: 750 },
    thickness: 1,
    color: rgb(0.7, 0.7, 0.7), // Light gray
  });
}

/**
 * Generate PDF from structured summary data
 */
export async function generatePDF(structuredSummary: {
  caseId?: string;
  location?: string;
  participants?: string[];
  relevance?: string;
  summaryText?: string;
  transcriptText?: string;
  translatedText?: string;
  timestamp?: string;
  userId?: string;
  generatedBy?: string;
  videoUrl?: string;
  video_url?: string; // Alternate field name
  reportDate?: string;
  translatedSummary?: string;
  // New fields from upload flow
  rawTranscript?: string;
  translatedTranscript?: string;
  geocodeResult?: any;
  // Support for alternate data structures
  transcript?: string;
  summary?: any;
  // Additional fields that might be in the data
  language?: string;
  metadata?: {
    language?: string;
    [key: string]: any;
  };
  // Allow flexible field access for debugging
  [key: string]: any;
}) {
  // Log input for debugging
  console.log('ðŸ”Ž DEBUG - PDF INPUT SUMMARY:', {
    caseId: structuredSummary.caseId,
    location: structuredSummary.location,
    geocodeResult: structuredSummary.geocodeResult?.formatted_address,
    rawTranscript: structuredSummary.rawTranscript ? `${structuredSummary.rawTranscript.substring(0, 30)}...` : 'none',
    translatedTranscript: structuredSummary.translatedTranscript ? `${structuredSummary.translatedTranscript.substring(0, 30)}...` : 'none',
    videoUrl: structuredSummary.videoUrl || structuredSummary.video_url,
    hasFields: {
      summaryText: !!structuredSummary.summaryText,
      transcriptText: !!structuredSummary.transcriptText,
      summary: !!structuredSummary.summary
    }
  });

  /*****************************************
   * FIELD EXTRACTION WITH EXPLICIT FALLBACKS
   *****************************************/
  
  // 1. CASE ID: Required field with fallback
  const caseId = structuredSummary.caseId || 'Unknown';
  
  // 2. LOCATION: Use address field first (required by user), then geocode result if available
  const location = structuredSummary.address ||
                   structuredSummary.geocodeResult?.formatted_address || 
                   structuredSummary.location || 
                   'Unknown Location';
  
  console.log('ðŸ“ LOCATION field will show:', location);
  
  // 3. REPORT DATE: Format nicely or use current date
  const reportDate = structuredSummary.reportDate || 
                    structuredSummary.timestamp || 
                    new Date().toISOString();
                    
  // Format the date for display
  const formattedDate = (() => {
    try {
      const date = new Date(reportDate);
      return date.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    } catch (e) {
      return reportDate; // Use as-is if parsing fails
    }
  })();
  
  // 4. PARTICIPANTS: Format comma-separated with fallback
  let participants = Array.isArray(structuredSummary.participants) ? 
                    structuredSummary.participants : [];
  if (participants.length === 0 && structuredSummary.keyParticipants) {
    participants = Array.isArray(structuredSummary.keyParticipants) ? 
      structuredSummary.keyParticipants : [String(structuredSummary.keyParticipants)];
  }
  const participantsText = participants.length > 0 ? 
                           participants.join(', ') : 
                           'Not listed';
  
  // 5. RELEVANCE: Simple fallback
  const relevance = structuredSummary.relevance || 'Not specified';
  
  // 6. TRANSLATED SUMMARY: with fallback - prioritize translatedTranscript as per user requirements
  const translatedSummary = structuredSummary.summary?.translatedTranscript || 
                          structuredSummary.translatedTranscript || 
                          structuredSummary.translatedSummary || 
                          structuredSummary.translatedText || 
                          'Translation not available';
  
  console.log('ðŸ”¤ ENGLISH TRANSLATION field will show:', translatedSummary.substring(0, 50) + '...');
  
  // 7. TRANSCRIPT: Prioritize rawTranscript as per user requirements
  const originalTranscript = structuredSummary.summary?.rawTranscript || 
                           structuredSummary.rawTranscript || 
                           structuredSummary.transcript || 
                           structuredSummary.transcriptText || 
                           'Transcript not available';
  
  console.log('ðŸ“” ORIGINAL TRANSCRIPT field will show:', originalTranscript.substring(0, 50) + '...');
  
  // 8. LANGUAGE CODE: Default to 'en'
  const language = structuredSummary.language || 
                  structuredSummary.metadata?.language || 
                  'en';
  
  // 9. VIDEO URL: For QR code generation
  const videoUrl = structuredSummary.videoUrl || 
                  structuredSummary.video_url || 
                  `https://proofai.app/view/${caseId}`;

  /*****************************************
   * PDF DOCUMENT CREATION
   *****************************************/
  
  // Create a new PDF document
  const pdfDoc = await PDFDocument.create();
  
  // Load the standard fonts
  const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  
  // Define standard page dimensions and margins
  const pageWidth = 612; // 8.5 inches
  const pageHeight = 792; // 11 inches
  const margin = 50;

  /*****************************************
   * PAGE 1: REPORT SUMMARY + TRANSLATION
   *****************************************/
  
  // Create page 1
  const page1 = pdfDoc.addPage([pageWidth, pageHeight]);
  
  // Add the header
  addHeader(page1, location, font, boldFont, margin, pageWidth);
  
  // REPORT SUMMARY section header - properly positioned with no overlap
  let yPos = 720; // Start position below header
  yPos = drawSectionHeader(page1, 'REPORT SUMMARY', margin, yPos, 14, boldFont);
  
  // Case ID - formatted and positioned properly
  page1.drawText('Case ID:', { 
    x: margin, 
    y: yPos, 
    size: 11, 
    color: rgb(0.4, 0, 0.6), // Purple color
    font: font 
  });
  
  page1.drawText(caseId, { 
    x: margin + 60, 
    y: yPos, 
    size: 11, 
    color: rgb(0.6, 0.4, 0.2), // Brown color
    font: font 
  });
  yPos -= 20; // Move down for next field
  
  // Report Date - formatted and positioned properly
  page1.drawText('Report Date:', { 
    x: margin, 
    y: yPos, 
    size: 11, 
    color: rgb(0.4, 0, 0.6), // Purple color
    font: font 
  });
  
  page1.drawText(formattedDate, { 
    x: margin + 80, 
    y: yPos, 
    size: 11, 
    color: rgb(0.6, 0.4, 0.2), // Brown color
    font: font 
  });
  yPos -= 20; // Move down for next field
  
  // Participants - formatted and positioned properly
  page1.drawText('Participants:', { 
    x: margin, 
    y: yPos, 
    size: 11, 
    color: rgb(0.4, 0, 0.6), // Purple color
    font: font 
  });
  
  page1.drawText(participantsText, { 
    x: margin + 80, 
    y: yPos, 
    size: 11, 
    color: rgb(0.6, 0.4, 0.2), // Brown color
    font: font 
  });
  yPos -= 20; // Move down for next field
  
  // Relevance - formatted and positioned properly
  page1.drawText('Relevance:', { 
    x: margin, 
    y: yPos, 
    size: 11, 
    color: rgb(0.4, 0, 0.6), // Purple color
    font: font 
  });
  
  page1.drawText(relevance, { 
    x: margin + 80, 
    y: yPos, 
    size: 11, 
    color: rgb(0.6, 0.4, 0.2), // Brown color
    font: font 
  });
  yPos -= 40; // Leave space before the next section
  
  // Add divider line
  page1.drawLine({
    start: { x: margin, y: yPos + 20 },
    end: { x: pageWidth - margin, y: yPos + 20 },
    thickness: 1,
    color: rgb(0.7, 0.7, 0.7), // Light gray
  });
  
  // ENGLISH TRANSLATION header - positioned properly with no overlap
  yPos = drawSectionHeader(page1, 'ENGLISH TRANSLATION', margin, yPos, 14, boldFont);
  
  // Display translated transcript with proper text wrapping
  console.log('ðŸ”´ ENGLISH TRANSLATION section will show:', 
    translatedSummary.substring(0, Math.min(50, translatedSummary.length)) + 
    (translatedSummary.length > 50 ? '...' : ''));
  
  const translatedLines = splitTextIntoLines(translatedSummary, font, 11, pageWidth - (2 * margin));
  for (const line of translatedLines) {
    page1.drawText(line, { 
      x: margin, 
      y: yPos, 
      size: 11, 
      font: font,
      color: rgb(0, 0, 0)
    });
    yPos -= 14; // Line height for proper spacing
    
    // Break if we're running out of space on the page
    if (yPos < 100) break;
  }

  /*****************************************
   * PAGE 2: TRANSCRIPT + QR CODE
   *****************************************/
  
  // Only create page 2 if we have a transcript
  const hasTranscript = originalTranscript && originalTranscript !== 'Transcript not available';
  const totalPages = hasTranscript ? 2 : 1;
  
  // Add footer to page 1
  addFooter(page1, 1, totalPages, font, pageWidth, margin);
  
  if (hasTranscript) {
    // Create page 2
    const page2 = pdfDoc.addPage([pageWidth, pageHeight]);
    
    // Add the header to page 2
    addHeader(page2, location, font, boldFont, margin, pageWidth);
    
    // ORIGINAL TRANSCRIPT header - positioned properly with no overlap
    yPos = 720; // Reset yPos for page 2
    yPos = drawSectionHeader(page2, `ORIGINAL TRANSCRIPT [${language}]`, margin, yPos, 14, boldFont);
    
    console.log('ðŸ”´ ORIGINAL TRANSCRIPT section will show:', 
      originalTranscript.substring(0, Math.min(50, originalTranscript.length)) + 
      (originalTranscript.length > 50 ? '...' : ''));
    
    // Display transcript with proper text wrapping
    const transcriptLines = splitTextIntoLines(originalTranscript, font, 11, pageWidth - (2 * margin));
    for (const line of transcriptLines) {
      page2.drawText(line, { 
        x: margin, 
        y: yPos, 
        size: 11, 
        font: font,
        color: rgb(0, 0, 0)
      });
      yPos -= 14; // Line height
      
      // Break if we're approaching the QR code area
      if (yPos < 400) break;
    }
    
    /*****************************************
     * QR CODE SECTION (PAGE 2)
     *****************************************/
    try {
      // Generate QR code
      const qrDataUrl = await QRCode.toDataURL(videoUrl, { margin: 0, scale: 4 });
      
      // Convert QR DataURL to PDF-compatible image bytes
      const qrImageBytes = await fetch(qrDataUrl).then((res) => res.arrayBuffer());
      
      // Embed QR code image in PDF
      const qrImage = await pdfDoc.embedPng(qrImageBytes);
      
      // Green banner background
      page2.drawRectangle({
        x: margin,
        y: 250,
        width: pageWidth - (margin * 2),
        height: 30,
        color: rgb(0.2, 0.8, 0.4), // Green color
      });

      // SCAN TO WATCH EVIDENCE text (centered in banner)
      page2.drawText('SCAN TO WATCH EVIDENCE', { 
        x: pageWidth / 2 - 80, // Center text in banner 
        y: 265, 
        size: 12, 
        color: rgb(0, 0, 0), // Black for better visibility
        font: boldFont 
      });
      
      // Display QR code (centered under banner)
      const qrSize = 100;
      const qrXCenter = pageWidth / 2 - qrSize / 2;
      page2.drawImage(qrImage, {
        x: qrXCenter,
        y: 130,
        width: qrSize,
        height: qrSize,
      });
      
      // Add "Click URL:" text below QR code
      page2.drawText('Click URL:', { 
        x: pageWidth / 2 - 30, // Center aligned
        y: 120, 
        size: 10, 
        font: boldFont,
        color: rgb(0, 0, 0)
      });
      
      // Add actual URL below
      page2.drawText(videoUrl, { 
        x: pageWidth / 2 - Math.min(videoUrl.length * 2.5, 100), // Center based on length
        y: 100, 
        size: 9, 
        font: font,
        color: rgb(0, 0, 0.8) // Blue for URL
      });
      
      // Add "Authorized Signature" area
      page2.drawLine({
        start: { x: margin, y: 200 },
        end: { x: margin + 150, y: 200 },
        thickness: 1,
        color: rgb(0, 0, 0),
      });
      
      page2.drawText('Authorized Signature', { 
        x: margin, 
        y: 185, 
        size: 8, 
        font: font 
      });
    } catch (err) {
      console.error('QR code generation failed:', err);
      // Continue without QR code if generation fails
    }
    
    // Add footer to page 2
    addFooter(page2, 2, totalPages, font, pageWidth, margin);
  } else {
    // If we only have one page, add QR code to page 1
    try {
      // Generate QR code
      const qrDataUrl = await QRCode.toDataURL(videoUrl, { margin: 0, scale: 4 });
      
      // Convert QR DataURL to PDF-compatible image bytes
      const qrImageBytes = await fetch(qrDataUrl).then((res) => res.arrayBuffer());
      
      // Embed QR code image in PDF
      const qrImage = await pdfDoc.embedPng(qrImageBytes);
      
      // Green box background for QR code on page 1
      page1.drawRectangle({
        x: margin,
        y: 150,
        width: 200,
        height: 100,
        color: rgb(0.2, 0.8, 0.4), // Green color
      });

      // QR code header text (white)
      page1.drawText('SCAN TO VIEW RECORDING', { 
        x: margin + 20, 
        y: 230, 
        size: 10, 
        color: rgb(1, 1, 1), // White
        font: boldFont 
      });
      
      // Display QR code
      page1.drawImage(qrImage, {
        x: margin + 60,
        y: 170,
        width: 80,
        height: 80,
      });
      
      // Add "Or visit: URL" text
      page1.drawText(`Or visit: ${videoUrl}`, { 
        x: margin + 10, 
        y: 160, 
        size: 9, 
        color: rgb(1, 1, 1), // White
        font: font 
      });
      
      // Add "Authorized Signature" area
      page1.drawLine({
        start: { x: margin, y: 120 },
        end: { x: margin + 150, y: 120 },
        thickness: 1,
        color: rgb(0, 0, 0),
      });
      
      page1.drawText('Authorized Signature', { 
        x: margin, 
        y: 105, 
        size: 8, 
        font: font 
      });
    } catch (err) {
      console.error('QR code generation failed:', err);
      // Continue without QR code if generation fails
    }
  }

  // Save and return the PDF
  const pdfBytes = await pdfDoc.save();
  return pdfBytes;
}
